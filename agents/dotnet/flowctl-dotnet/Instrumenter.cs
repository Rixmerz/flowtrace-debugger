using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace FlowctlDotnet;

/// <summary>
/// Auto-instruments C# code by adding [Trace] attributes to methods.
/// Uses Roslyn's SyntaxRewriter to modify syntax trees.
/// </summary>
public class Instrumenter
{
    public InstrumentationResult InstrumentFile(string filePath, bool dryRun)
    {
        var result = new InstrumentationResult();

        try
        {
            var code = File.ReadAllText(filePath);
            var tree = CSharpSyntaxTree.ParseText(code);
            var root = tree.GetRoot();

            // Check if generated file
            if (IsGeneratedFile(root))
            {
                result.Success = false;
                result.ErrorMessage = "Cannot instrument generated files";
                return result;
            }

            // Rewrite syntax tree to add [Trace] attributes
            var rewriter = new TraceAttributeRewriter();
            var newRoot = rewriter.Visit(root);

            result.MethodsInstrumented = rewriter.InstrumentedMethods.Count;
            result.InstrumentedMethods = rewriter.InstrumentedMethods;

            if (result.MethodsInstrumented > 0 && !dryRun)
            {
                // Write modified code back to file
                var newCode = newRoot.ToFullString();
                File.WriteAllText(filePath, newCode);
            }

            result.Success = true;
        }
        catch (Exception ex)
        {
            result.Success = false;
            result.ErrorMessage = ex.Message;
        }

        return result;
    }

    private bool IsGeneratedFile(SyntaxNode root)
    {
        var trivia = root.GetLeadingTrivia();
        return trivia.Any(t => t.ToString().Contains("<auto-generated"));
    }
}

/// <summary>
/// Syntax rewriter that adds [Trace] attributes to instrumentable methods.
/// </summary>
internal class TraceAttributeRewriter : CSharpSyntaxRewriter
{
    public List<string> InstrumentedMethods { get; } = new();

    public override SyntaxNode? VisitMethodDeclaration(MethodDeclarationSyntax node)
    {
        // Check if method should be instrumented
        if (!ShouldInstrument(node))
        {
            return base.VisitMethodDeclaration(node);
        }

        // Create [Trace] attribute
        var traceAttribute = SyntaxFactory.Attribute(SyntaxFactory.IdentifierName("Trace"));
        var attributeList = SyntaxFactory.AttributeList(
            SyntaxFactory.SingletonSeparatedList(traceAttribute))
            .WithTrailingTrivia(SyntaxFactory.CarriageReturnLineFeed);

        // Add attribute to method
        var newNode = node.AddAttributeLists(attributeList);

        // Track instrumented method
        var className = GetContainingClassName(node);
        var methodSignature = $"{className}.{node.Identifier.Text}";
        InstrumentedMethods.Add(methodSignature);

        return base.VisitMethodDeclaration(newNode);
    }

    private bool ShouldInstrument(MethodDeclarationSyntax method)
    {
        // Skip if already has [Trace]
        if (HasTraceAttribute(method))
        {
            return false;
        }

        // Skip if has [TraceIgnore]
        if (HasTraceIgnoreAttribute(method))
        {
            return false;
        }

        // Must be public or internal
        if (!IsPublic(method) && !IsInternal(method))
        {
            return false;
        }

        // Skip property accessors
        if (method.Parent is AccessorDeclarationSyntax)
        {
            return false;
        }

        // Skip operator overloads
        if (method.Modifiers.Any(m => m.IsKind(SyntaxKind.OperatorKeyword)))
        {
            return false;
        }

        // Skip common methods that shouldn't be traced
        var methodName = method.Identifier.Text;
        if (methodName is "ToString" or "Equals" or "GetHashCode" or "Dispose")
        {
            return false;
        }

        return true;
    }

    private bool IsPublic(MethodDeclarationSyntax method)
    {
        return method.Modifiers.Any(m => m.IsKind(SyntaxKind.PublicKeyword));
    }

    private bool IsInternal(MethodDeclarationSyntax method)
    {
        return method.Modifiers.Any(m => m.IsKind(SyntaxKind.InternalKeyword));
    }

    private bool HasTraceAttribute(MethodDeclarationSyntax method)
    {
        return method.AttributeLists
            .SelectMany(al => al.Attributes)
            .Any(attr => attr.Name.ToString() is "Trace" or "TraceAttribute");
    }

    private bool HasTraceIgnoreAttribute(MethodDeclarationSyntax method)
    {
        return method.AttributeLists
            .SelectMany(al => al.Attributes)
            .Any(attr => attr.Name.ToString() is "TraceIgnore" or "TraceIgnoreAttribute");
    }

    private string GetContainingClassName(MethodDeclarationSyntax method)
    {
        var classDecl = method.Ancestors().OfType<ClassDeclarationSyntax>().FirstOrDefault();
        return classDecl?.Identifier.Text ?? "Unknown";
    }
}

/// <summary>
/// Result of instrumentation operation.
/// </summary>
public class InstrumentationResult
{
    public bool Success { get; set; }
    public int MethodsInstrumented { get; set; }
    public List<string> InstrumentedMethods { get; set; } = new();
    public string? ErrorMessage { get; set; }
}
