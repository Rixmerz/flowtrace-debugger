using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace FlowctlDotnet;

/// <summary>
/// Analyzes C# code to identify instrumentable methods and provide statistics.
/// Uses Roslyn for syntax analysis.
/// </summary>
public class Analyzer
{
    public AnalysisStats AnalyzePath(string path)
    {
        var stats = new AnalysisStats();

        if (File.Exists(path))
        {
            AnalyzeFile(path, stats);
        }
        else if (Directory.Exists(path))
        {
            var csFiles = Directory.GetFiles(path, "*.cs", SearchOption.AllDirectories)
                .Where(f => !f.Contains("obj") && !f.Contains("bin") && !f.Contains(".g.cs"))
                .ToList();

            foreach (var file in csFiles)
            {
                AnalyzeFile(file, stats);
            }
        }

        return stats;
    }

    private void AnalyzeFile(string filePath, AnalysisStats stats)
    {
        try
        {
            var code = File.ReadAllText(filePath);
            var tree = CSharpSyntaxTree.ParseText(code);
            var root = tree.GetRoot();

            // Skip generated files
            if (IsGeneratedFile(root))
            {
                stats.GeneratedFiles++;
                return;
            }

            var fileDetail = new FileDetail
            {
                FilePath = filePath,
                FileName = Path.GetFileName(filePath)
            };

            var classes = root.DescendantNodes().OfType<ClassDeclarationSyntax>().ToList();
            fileDetail.TotalClasses = classes.Count;
            stats.TotalClasses += classes.Count;

            foreach (var classDecl in classes)
            {
                var methods = classDecl.DescendantNodes().OfType<MethodDeclarationSyntax>().ToList();
                fileDetail.TotalMethods += methods.Count;
                stats.TotalMethods += methods.Count;

                foreach (var method in methods)
                {
                    if (IsInstrumentable(method))
                    {
                        fileDetail.InstrumentableMethods++;
                        stats.InstrumentableMethods++;

                        if (HasTraceAttribute(method))
                        {
                            fileDetail.AlreadyInstrumented++;
                            stats.AlreadyInstrumented++;
                        }
                    }
                    else if (!IsPublic(method))
                    {
                        fileDetail.NonPublicMethods++;
                        stats.NonPublicMethods++;
                    }
                }
            }

            if (fileDetail.TotalMethods > 0)
            {
                stats.TotalFiles++;
                stats.FileDetails.Add(fileDetail);
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"⚠️  Warning: Failed to analyze {filePath}: {ex.Message}");
        }
    }

    private bool IsGeneratedFile(SyntaxNode root)
    {
        // Check for auto-generated comment
        var trivia = root.GetLeadingTrivia();
        return trivia.Any(t => t.ToString().Contains("<auto-generated"));
    }

    private bool IsInstrumentable(MethodDeclarationSyntax method)
    {
        // Must be public or internal
        if (!IsPublic(method) && !IsInternal(method))
        {
            return false;
        }

        // Skip constructors, property accessors, operator overloads
        if (IsConstructor(method) || IsPropertyAccessor(method) || IsOperator(method))
        {
            return false;
        }

        // Skip methods with [TraceIgnore]
        if (HasTraceIgnoreAttribute(method))
        {
            return false;
        }

        // Skip methods with specific names
        var methodName = method.Identifier.Text;
        if (methodName.StartsWith("Get") && methodName.EndsWith("HashCode"))
        {
            return false;
        }

        if (methodName is "ToString" or "Equals" or "GetHashCode" or "Dispose")
        {
            return false;
        }

        return true;
    }

    private bool IsPublic(MethodDeclarationSyntax method)
    {
        return method.Modifiers.Any(m => m.IsKind(SyntaxKind.PublicKeyword));
    }

    private bool IsInternal(MethodDeclarationSyntax method)
    {
        return method.Modifiers.Any(m => m.IsKind(SyntaxKind.InternalKeyword));
    }

    private bool IsConstructor(MethodDeclarationSyntax method)
    {
        // Constructors don't have a return type in the syntax
        return false; // MethodDeclarationSyntax is not used for constructors
    }

    private bool IsPropertyAccessor(MethodDeclarationSyntax method)
    {
        return method.Parent is AccessorDeclarationSyntax;
    }

    private bool IsOperator(MethodDeclarationSyntax method)
    {
        return method.Modifiers.Any(m => m.IsKind(SyntaxKind.OperatorKeyword));
    }

    private bool HasTraceAttribute(MethodDeclarationSyntax method)
    {
        return method.AttributeLists
            .SelectMany(al => al.Attributes)
            .Any(attr => attr.Name.ToString() is "Trace" or "TraceAttribute");
    }

    private bool HasTraceIgnoreAttribute(MethodDeclarationSyntax method)
    {
        return method.AttributeLists
            .SelectMany(al => al.Attributes)
            .Any(attr => attr.Name.ToString() is "TraceIgnore" or "TraceIgnoreAttribute");
    }
}

/// <summary>
/// Statistics from code analysis.
/// </summary>
public class AnalysisStats
{
    public int TotalFiles { get; set; }
    public int TotalClasses { get; set; }
    public int TotalMethods { get; set; }
    public int InstrumentableMethods { get; set; }
    public int AlreadyInstrumented { get; set; }
    public int NonPublicMethods { get; set; }
    public int GeneratedFiles { get; set; }
    public List<FileDetail> FileDetails { get; set; } = new();
}

/// <summary>
/// Details for a single file.
/// </summary>
public class FileDetail
{
    public string FilePath { get; set; } = string.Empty;
    public string FileName { get; set; } = string.Empty;
    public int TotalClasses { get; set; }
    public int TotalMethods { get; set; }
    public int InstrumentableMethods { get; set; }
    public int AlreadyInstrumented { get; set; }
    public int NonPublicMethods { get; set; }
}
