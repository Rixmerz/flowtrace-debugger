using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Flowtrace.Agent.SourceGenerator;

/// <summary>
/// Source Generator that automatically instruments methods marked with [Trace] attribute.
/// Generates ENTER, EXIT, and EXCEPTION logging code at compile-time.
/// </summary>
[Generator]
public class FlowtraceSourceGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
    {
        // Register syntax receiver to find [Trace] attributes
        context.RegisterForSyntaxNotifications(() => new TraceSyntaxReceiver());
    }

    public void Execute(GeneratorExecutionContext context)
    {
        if (context.SyntaxReceiver is not TraceSyntaxReceiver receiver)
            return;

        foreach (var methodDeclaration in receiver.CandidateMethods)
        {
            var semanticModel = context.Compilation.GetSemanticModel(methodDeclaration.SyntaxTree);
            var methodSymbol = semanticModel.GetDeclaredSymbol(methodDeclaration);

            if (methodSymbol == null)
                continue;

            // Check if method has [Trace] attribute
            if (!HasTraceAttribute(methodSymbol))
                continue;

            // Check if method or containing class has [TraceIgnore]
            if (HasTraceIgnoreAttribute(methodSymbol) || HasTraceIgnoreAttribute(methodSymbol.ContainingType))
                continue;

            // Generate instrumented version
            var source = GenerateTracedMethod(methodDeclaration, methodSymbol, semanticModel);

            if (!string.IsNullOrEmpty(source))
            {
                var hint = $"{methodSymbol.ContainingType.ToDisplayString().Replace(".", "_")}_{methodSymbol.Name}_Trace.g.cs";
                context.AddSource(hint, SourceText.From(source, Encoding.UTF8));
            }
        }
    }

    private static bool HasTraceAttribute(ISymbol symbol)
    {
        return symbol.GetAttributes()
            .Any(attr => attr.AttributeClass?.Name == "TraceAttribute");
    }

    private static bool HasTraceIgnoreAttribute(ISymbol symbol)
    {
        return symbol.GetAttributes()
            .Any(attr => attr.AttributeClass?.Name == "TraceIgnoreAttribute");
    }

    private static string GenerateTracedMethod(
        MethodDeclarationSyntax methodDeclaration,
        IMethodSymbol methodSymbol,
        SemanticModel semanticModel)
    {
        var namespaceName = methodSymbol.ContainingNamespace.ToDisplayString();
        var className = methodSymbol.ContainingType.Name;
        var methodName = methodSymbol.Name;
        var isAsync = methodSymbol.IsAsync;
        var returnType = methodSymbol.ReturnType.ToDisplayString();

        // Build parameter list
        var parameters = string.Join(", ",
            methodSymbol.Parameters.Select(p => $"{p.Type.ToDisplayString()} {p.Name}"));

        // Build arguments dictionary
        var argsDict = BuildArgumentsDictionary(methodSymbol);

        // Generate source
        var source = new StringBuilder();

        source.AppendLine("// <auto-generated/>");
        source.AppendLine("#nullable enable");
        source.AppendLine();
        source.AppendLine($"namespace {namespaceName}");
        source.AppendLine("{");
        source.AppendLine($"    partial class {className}");
        source.AppendLine("    {");

        if (isAsync)
        {
            source.AppendLine($"        {GetAccessModifier(methodSymbol)} async {returnType} {methodName}Traced({parameters})");
            source.AppendLine("        {");
            source.AppendLine($"            var __flowtrace_stopwatch = System.Diagnostics.Stopwatch.StartNew();");
            source.AppendLine();
            source.AppendLine($"            // Log ENTER event");
            source.AppendLine($"            Flowtrace.Agent.FlowtraceTracer.LogEvent(");
            source.AppendLine($"                Flowtrace.Agent.TraceEvent.Enter(\"{className}\", \"{methodName}\", {argsDict})");
            source.AppendLine("            );");
            source.AppendLine();
            source.AppendLine("            try");
            source.AppendLine("            {");
            source.AppendLine($"                var __flowtrace_result = await {methodName}({GetParameterNames(methodSymbol)});");
            source.AppendLine();
            source.AppendLine("                // Log EXIT event");
            source.AppendLine("                __flowtrace_stopwatch.Stop();");
            source.AppendLine("                Flowtrace.Agent.FlowtraceTracer.LogEvent(");
            source.AppendLine($"                    Flowtrace.Agent.TraceEvent.Exit(\"{className}\", \"{methodName}\", __flowtrace_result, __flowtrace_stopwatch.Elapsed.TotalMilliseconds)");
            source.AppendLine("                );");
            source.AppendLine();
            source.AppendLine("                return __flowtrace_result;");
            source.AppendLine("            }");
            source.AppendLine("            catch (System.Exception __flowtrace_ex)");
            source.AppendLine("            {");
            source.AppendLine("                // Log EXCEPTION event");
            source.AppendLine("                __flowtrace_stopwatch.Stop();");
            source.AppendLine("                Flowtrace.Agent.FlowtraceTracer.LogEvent(");
            source.AppendLine($"                    Flowtrace.Agent.TraceEvent.Exception(\"{className}\", \"{methodName}\", __flowtrace_ex.ToString(), __flowtrace_stopwatch.Elapsed.TotalMilliseconds)");
            source.AppendLine("                );");
            source.AppendLine("                throw;");
            source.AppendLine("            }");
        }
        else
        {
            source.AppendLine($"        {GetAccessModifier(methodSymbol)} {returnType} {methodName}Traced({parameters})");
            source.AppendLine("        {");
            source.AppendLine($"            var __flowtrace_stopwatch = System.Diagnostics.Stopwatch.StartNew();");
            source.AppendLine();
            source.AppendLine($"            // Log ENTER event");
            source.AppendLine($"            Flowtrace.Agent.FlowtraceTracer.LogEvent(");
            source.AppendLine($"                Flowtrace.Agent.TraceEvent.Enter(\"{className}\", \"{methodName}\", {argsDict})");
            source.AppendLine("            );");
            source.AppendLine();
            source.AppendLine("            try");
            source.AppendLine("            {");
            source.AppendLine($"                var __flowtrace_result = {methodName}({GetParameterNames(methodSymbol)});");
            source.AppendLine();
            source.AppendLine("                // Log EXIT event");
            source.AppendLine("                __flowtrace_stopwatch.Stop();");
            source.AppendLine("                Flowtrace.Agent.FlowtraceTracer.LogEvent(");
            source.AppendLine($"                    Flowtrace.Agent.TraceEvent.Exit(\"{className}\", \"{methodName}\", __flowtrace_result, __flowtrace_stopwatch.Elapsed.TotalMilliseconds)");
            source.AppendLine("                );");
            source.AppendLine();
            source.AppendLine("                return __flowtrace_result;");
            source.AppendLine("            }");
            source.AppendLine("            catch (System.Exception __flowtrace_ex)");
            source.AppendLine("            {");
            source.AppendLine("                // Log EXCEPTION event");
            source.AppendLine("                __flowtrace_stopwatch.Stop();");
            source.AppendLine("                Flowtrace.Agent.FlowtraceTracer.LogEvent(");
            source.AppendLine($"                    Flowtrace.Agent.TraceEvent.Exception(\"{className}\", \"{methodName}\", __flowtrace_ex.ToString(), __flowtrace_stopwatch.Elapsed.TotalMilliseconds)");
            source.AppendLine("                );");
            source.AppendLine("                throw;");
            source.AppendLine("            }");
        }

        source.AppendLine("        }");
        source.AppendLine("    }");
        source.AppendLine("}");

        return source.ToString();
    }

    private static string GetAccessModifier(IMethodSymbol method)
    {
        return method.DeclaredAccessibility switch
        {
            Accessibility.Public => "public",
            Accessibility.Private => "private",
            Accessibility.Protected => "protected",
            Accessibility.Internal => "internal",
            Accessibility.ProtectedOrInternal => "protected internal",
            _ => "private"
        };
    }

    private static string BuildArgumentsDictionary(IMethodSymbol method)
    {
        if (!method.Parameters.Any())
            return "null";

        var args = method.Parameters.Select(p => $"[\"{p.Name}\"] = {p.Name}");
        return $"new System.Collections.Generic.Dictionary<string, object> {{ {string.Join(", ", args)} }}";
    }

    private static string GetParameterNames(IMethodSymbol method)
    {
        return string.Join(", ", method.Parameters.Select(p => p.Name));
    }
}

/// <summary>
/// Syntax receiver to collect method declarations with potential [Trace] attributes
/// </summary>
internal class TraceSyntaxReceiver : ISyntaxReceiver
{
    public List<MethodDeclarationSyntax> CandidateMethods { get; } = new();

    public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
    {
        // Collect methods with attributes
        if (syntaxNode is MethodDeclarationSyntax methodDeclaration &&
            methodDeclaration.AttributeLists.Count > 0)
        {
            CandidateMethods.Add(methodDeclaration);
        }
    }
}
